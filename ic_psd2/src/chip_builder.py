#!/usr/bin/env python3
"""
ChipXMLBuilder
--------------------------------------
芯片级XML构建器，将多个子模块XML合并为完整的芯片级寄存器定义。

功能：
1. 支持多模块（CDR、TX、RX、PLL等）合并
2. 支持单模块多实例（如 CDR -> CdrUp/CdrDp1~CdrDp4）
3. 自动地址映射（基址 + 相对地址）
4. 地址冲突检测
5. 实例级属性覆盖

依赖：openpyxl（读取Excel配置）

用法示例：
    # 方式1: 使用Excel配置
    builder = ChipXMLBuilder()
    builder.load_config('chip_config.xlsx')
    builder.build()
    builder.export_xml('output/GSU1K1_Chip.xml')

    # 方式2: 代码方式构建
    builder = ChipXMLBuilder()
    builder.set_chip_info(name='GSU1K1r4', version='1.0.0')
    builder.add_module('CDR', './modules/CDR.xml')
    builder.add_instance('CdrUp', 'CDR', base_addr=0x1000)
    builder.add_instance('CdrDp1', 'CDR', base_addr=0x1100)
    builder.build()
    builder.export_xml('output.xml')

作者：yfzhao
日期：2024
--------------------------------------
"""

import xml.etree.ElementTree as ET
from xml.dom import minidom
import json
import os
import re
import warnings
from dataclasses import dataclass, field as dataclass_field
from typing import List, Dict, Optional, Tuple, Any
from collections import defaultdict

try:
    from openpyxl import load_workbook, Workbook
    from openpyxl.styles import Font, Alignment, Border, Side, PatternFill
    from openpyxl.utils import get_column_letter

    OPENPYXL_AVAILABLE = True
except ImportError:
    OPENPYXL_AVAILABLE = False

# YAML support
try:
    import yaml

    YAML_AVAILABLE = True
except ImportError:
    YAML_AVAILABLE = False


@dataclass
class InstanceConfig:
    """实例配置"""

    name: str  # 实例名，如 "CdrUp"
    module_name: str  # 引用模块名
    base_addr: int  # 基地址，如 0x1000
    instance_id: int = 0  # 实例编号
    enable: bool = True  # 是否启用
    caption: Optional[str] = None  # 显示名（默认同name）

    def __post_init__(self):
        if self.caption is None:
            self.caption = self.name


@dataclass
class OverrideRule:
    """字段属性覆盖规则"""

    instance_pattern: str  # 实例名匹配（支持正则）
    field_pattern: str  # 字段名匹配（支持正则）
    property_name: str  # 属性名
    new_value: str  # 新值


@dataclass
class ChipInfo:
    """芯片信息"""

    name: str = "UnknownChip"
    version: str = "1.0.0"
    author: str = "AutoGenerated"
    description: str = ""
    i2c_address: str = "0xB0"
    wordsize: int = 8
    raddr_wordsize: int = 16


class ChipXMLBuilder:
    """
    芯片级XML构建器

    将多个子模块XML文件合并为完整的芯片级寄存器定义XML，
    支持多实例、地址映射、冲突检测等功能。
    """

    def __init__(self):
        """初始化构建器"""
        self.chip_info = ChipInfo()
        self.modules: Dict[str, "ModuleParser"] = {}  # module_name -> parser
        self.instances: List[InstanceConfig] = []
        self.overrides: List[OverrideRule] = []
        self._built_tree: Optional[ET.Element] = None

    def init_config(self, output_path: str = "chip_config.yaml"):
        """
        生成示例配置文件模板（YAML格式）

        在调用 load_config() 之前，可以先调用此方法生成配置模板，
        然后根据模板填写实际的模块和实例信息。

        Args:
            output_path: 输出文件路径，默认为 'chip_config.yaml'

        Returns:
            生成的文件路径

        Example:
            >>> builder = ChipXMLBuilder()
            >>> builder.init_config('my_chip.yaml')
            >>> # 编辑 my_chip.yaml 填写配置
            >>> builder.load_config('my_chip.yaml')
        """
        if not YAML_AVAILABLE:
            raise ImportError("请先安装PyYAML: pip install pyyaml")

        config = {
            "chip_info": {
                "name": "GSU1K1r4",
                "version": "1.0.0",
                "author": "YourName",
                "description": "GSU1K1 Register Map",
                "i2c_address": "0xB0",
                "wordsize": 8,
                "raddr_wordsize": 16,
            },
            "modules": [
                {
                    "module_name": "CDR",
                    "xml_path": "./modules/CDR.xml",
                    "description": "Clock Data Recovery 模块",
                },
                {
                    "module_name": "TX",
                    "xml_path": "./modules/TX.xml",
                    "description": "Transmitter PHY 模块",
                },
                {
                    "module_name": "RX",
                    "xml_path": "./modules/RX.xml",
                    "description": "Receiver PHY 模块",
                },
            ],
            "instances": [
                {
                    "name": "CdrUp",
                    "module_name": "CDR",
                    "base_addr": "0x1000",
                    "instance_id": 0,
                    "enable": True,
                    "caption": "CdrUp",
                },
                {
                    "name": "CdrDp1",
                    "module_name": "CDR",
                    "base_addr": "0x1100",
                    "instance_id": 1,
                    "enable": True,
                    "caption": "CdrDp1",
                },
                {
                    "name": "CdrDp2",
                    "module_name": "CDR",
                    "base_addr": "0x1200",
                    "instance_id": 2,
                    "enable": True,
                    "caption": "CdrDp2",
                },
                {
                    "name": "CdrDp3",
                    "module_name": "CDR",
                    "base_addr": "0x1300",
                    "instance_id": 3,
                    "enable": True,
                    "caption": "CdrDp3",
                },
                {
                    "name": "CdrDp4",
                    "module_name": "CDR",
                    "base_addr": "0x1400",
                    "instance_id": 4,
                    "enable": True,
                    "caption": "CdrDp4",
                },
            ],
            "overrides": [
                # {'instance_pattern': 'CdrUp', 'field_pattern': 'i2c_cdr_meh_man_start', 'property': 'defaultvalue', 'new_value': '0x1'},
            ],
        }

        # 添加 YAML 注释说明
        yaml_content = """# Chip XML Builder 配置文件
# 用于配置芯片级XML的构建参数

# 芯片基本信息
"""
        yaml_content += yaml.dump(config, allow_unicode=True, sort_keys=False)
        yaml_content += """
# 配置说明：
# 
# chip_info: 芯片基本信息
#   - name: 芯片名称（英文，无空格）
#   - version: 版本号
#   - author: 作者
#   - description: 描述
#   - i2c_address: 默认I2C设备地址（十六进制）
#   - wordsize: 数据位宽（bit）
#   - raddr_wordsize: 寄存器地址位宽（bit）
#
# modules: 模块定义列表
#   - module_name: 模块标识名
#   - xml_path: XML文件路径
#   - description: 描述（可选）
#
# instances: 实例映射列表
#   - name: 实例名
#   - module_name: 引用的模块名
#   - base_addr: 基地址（十六进制字符串，如 "0x1000"）
#   - instance_id: 实例编号（可选，默认0）
#   - enable: 是否启用（可选，默认true）
#   - caption: 显示名（可选，默认与name相同）
#
# overrides: 属性覆盖规则（可选）
#   - instance_pattern: 正则匹配实例名（如 "Cdr.*"）
#   - field_pattern: 正则匹配字段名（如 ".*_man_en.*"）
#   - property: 要修改的属性（defaultvalue/description/access）
#   - new_value: 新值
"""

        os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(yaml_content)

        print(f"配置模板已生成: {output_path}")
        print(f"请编辑此文件填写实际的模块和实例信息")
        return output_path

    def set_chip_info(self, **kwargs):
        """
        设置芯片信息

        Args:
            name: 芯片名称
            version: 版本号
            author: 作者
            description: 描述
            i2c_address: I2C地址
            wordsize: 数据位宽
            raddr_wordsize: 地址位宽
        """
        for key, value in kwargs.items():
            if hasattr(self.chip_info, key):
                setattr(self.chip_info, key, value)

    def load_config(self, config_path: str):
        """
        从YAML配置文件加载配置

        Args:
            config_path: YAML配置文件路径 (.yaml/.yml)

        Raises:
            FileNotFoundError: 配置文件不存在
            ImportError: 未安装PyYAML
            ValueError: 配置格式错误
        """
        if not YAML_AVAILABLE:
            raise ImportError("请先安装PyYAML: pip install pyyaml")

        if not os.path.exists(config_path):
            raise FileNotFoundError(f"配置文件不存在: {config_path}")

        with open(config_path, "r", encoding="utf-8") as f:
            config = yaml.safe_load(f)

        if not config:
            raise ValueError(f"配置文件为空或格式错误: {config_path}")

        # 解析 ChipInfo
        if "chip_info" in config:
            self._parse_chip_info_yaml(config["chip_info"])

        # 解析 Modules
        if "modules" in config:
            for module_data in config["modules"]:
                if (
                    module_data
                    and module_data.get("module_name")
                    and module_data.get("xml_path")
                ):
                    self.add_module(module_data["module_name"], module_data["xml_path"])

        # 解析 Instances
        if "instances" in config:
            for inst_data in config["instances"]:
                if inst_data and inst_data.get("name") and inst_data.get("module_name"):
                    # 解析基地址（支持十六进制字符串）
                    base_addr = inst_data.get("base_addr", 0)
                    if isinstance(base_addr, str):
                        base_addr = int(base_addr, 0)  # 自动检测进制

                    instance_id = int(inst_data.get("instance_id", 0))
                    enable = bool(inst_data.get("enable", True))
                    caption = inst_data.get("caption") or inst_data["name"]

                    self.add_instance(
                        name=inst_data["name"],
                        module_name=inst_data["module_name"],
                        base_addr=base_addr,
                        instance_id=instance_id,
                        enable=enable,
                        caption=caption,
                    )

        # 解析 Overrides (可选)
        if "overrides" in config:
            for override_data in config["overrides"]:
                if override_data and override_data.get("instance_pattern"):
                    rule = OverrideRule(
                        instance_pattern=override_data.get("instance_pattern", ""),
                        field_pattern=override_data.get("field_pattern", ""),
                        property_name=override_data.get("property", ""),
                        new_value=str(override_data.get("new_value", "")),
                    )
                    self.overrides.append(rule)

    def _parse_chip_info_yaml(self, chip_info_data: dict):
        """解析ChipInfo YAML数据"""
        for key, value in chip_info_data.items():
            if hasattr(self.chip_info, key):
                # 类型转换
                if key in ["wordsize", "raddr_wordsize"]:
                    value = int(value)
                setattr(self.chip_info, key, value)

    def _load_config_excel(self, config_path: str):
        """
        从Excel配置文件加载配置（遗留方法，不推荐）

        Args:
            config_path: Excel配置文件路径 (.xlsx)
        """
        warnings.warn(
            "Excel配置已弃用，请使用YAML格式。未来版本将移除对Excel的支持。",
            DeprecationWarning,
            stacklevel=2,
        )

        if not OPENPYXL_AVAILABLE:
            raise ImportError("请先安装openpyxl: pip install openpyxl")

        wb = load_workbook(config_path)

        # 解析 ChipInfo
        if "ChipInfo" in wb.sheetnames:
            self._parse_chip_info_excel(wb["ChipInfo"])

        # 解析 Modules
        if "Modules" in wb.sheetnames:
            self._parse_modules_excel(wb["Modules"])

        # 解析 Instances
        if "Instances" in wb.sheetnames:
            self._parse_instances_excel(wb["Instances"])

        # 解析 Overrides (可选)
        if "Overrides" in wb.sheetnames:
            self._parse_overrides_excel(wb["Overrides"])

        wb.close()

    def _parse_chip_info_excel(self, ws):
        """解析ChipInfo工作表（遗留方法）"""
        for row in ws.iter_rows(min_row=2, values_only=True):
            if len(row) >= 2 and row[0] and row[1]:
                key, value = row[0], row[1]
                if hasattr(self.chip_info, key):
                    # 类型转换
                    if key in ["wordsize", "raddr_wordsize"]:
                        value = int(value)
                    setattr(self.chip_info, key, value)

    def _parse_modules_excel(self, ws):
        """解析Modules工作表（遗留方法）"""
        headers = [cell.value for cell in ws[1]]

        for row in ws.iter_rows(min_row=2, values_only=True):
            if not row[0]:
                continue

            data = dict(zip(headers, row))
            module_name = data.get("module_name")
            xml_path = data.get("xml_path")

            if module_name and xml_path:
                self.add_module(module_name, xml_path)

    def _parse_instances_excel(self, ws):
        """解析Instances工作表（遗留方法）"""
        headers = [cell.value for cell in ws[1]]

        for row in ws.iter_rows(min_row=2, values_only=True):
            if not row[0]:
                continue

            data = dict(zip(headers, row))

            instance_name = data.get("instance_name")
            module_name = data.get("module_name")
            base_addr = data.get("base_addr", 0)

            if instance_name and module_name:
                # 解析基地址（支持十六进制字符串）
                if isinstance(base_addr, str):
                    base_addr = int(base_addr, 0)  # 自动检测进制

                instance_id = int(data.get("instance_id", 0))
                enable = str(data.get("enable", "TRUE")).upper() == "TRUE"
                caption = data.get("caption") or instance_name

                self.add_instance(
                    name=instance_name,
                    module_name=module_name,
                    base_addr=base_addr,
                    instance_id=instance_id,
                    enable=enable,
                    caption=caption,
                )

    def _parse_overrides_excel(self, ws):
        """解析Overrides工作表（遗留方法）"""
        headers = [cell.value for cell in ws[1]]

        for row in ws.iter_rows(min_row=2, values_only=True):
            if not row[0]:
                continue

            data = dict(zip(headers, row))

            rule = OverrideRule(
                instance_pattern=data.get("instance_pattern", ""),
                field_pattern=data.get("field_pattern", ""),
                property_name=data.get("property", ""),
                new_value=str(data.get("new_value", "")),
            )
            self.overrides.append(rule)

    def add_module(self, module_name: str, xml_path: str) -> "ChipXMLBuilder":
        """
        添加子模块

        Args:
            module_name: 模块标识名
            xml_path: XML文件路径

        Returns:
            self，支持链式调用
        """
        if not os.path.exists(xml_path):
            raise FileNotFoundError(f"模块XML不存在: {xml_path}")

        parser = ModuleParser(xml_path)
        self.modules[module_name] = parser
        return self

    def add_instance(
        self,
        name: str,
        module_name: str,
        base_addr: int,
        instance_id: int = 0,
        enable: bool = True,
        caption: Optional[str] = None,
    ) -> "ChipXMLBuilder":
        """
        添加实例

        Args:
            name: 实例名
            module_name: 引用的模块名
            base_addr: 基地址
            instance_id: 实例编号
            enable: 是否启用
            caption: 显示名

        Returns:
            self，支持链式调用
        """
        config = InstanceConfig(
            name=name,
            module_name=module_name,
            base_addr=base_addr,
            instance_id=instance_id,
            enable=enable,
            caption=caption,
        )
        self.instances.append(config)
        return self

    def add_override(
        self,
        instance_pattern: str,
        field_pattern: str,
        property_name: str,
        new_value: str,
    ) -> "ChipXMLBuilder":
        """
        添加字段覆盖规则

        Args:
            instance_pattern: 实例名匹配（正则）
            field_pattern: 字段名匹配（正则）
            property_name: 属性名
            new_value: 新值

        Returns:
            self，支持链式调用
        """
        rule = OverrideRule(
            instance_pattern=instance_pattern,
            field_pattern=field_pattern,
            property_name=property_name,
            new_value=new_value,
        )
        self.overrides.append(rule)
        return self

    def check_address_conflict(self) -> List[Tuple[str, str, int, int, int]]:
        """
        检查地址冲突

        Returns:
            冲突列表，每项为 (instance1, instance2, addr1, addr2, size)
        """
        conflicts = []
        address_ranges = []

        for inst in self.instances:
            if not inst.enable:
                continue

            if inst.module_name not in self.modules:
                continue

            parser = self.modules[inst.module_name]
            min_addr, max_addr = parser.get_address_range()

            abs_start = inst.base_addr + min_addr
            abs_end = inst.base_addr + max_addr

            address_ranges.append((inst.name, abs_start, abs_end))

        # 检查重叠
        for i, (name1, start1, end1) in enumerate(address_ranges):
            for name2, start2, end2 in address_ranges[i + 1 :]:
                if max(start1, start2) <= min(end1, end2):
                    conflicts.append(
                        (
                            name1,
                            name2,
                            start1,
                            start2,
                            min(end1, end2) - max(start1, start2) + 1,
                        )
                    )

        return conflicts

    def build(self) -> ET.Element:
        """
        执行构建

        Returns:
            根Element

        Raises:
            ValueError: 配置错误
            RuntimeError: 构建失败
        """
        # 检查地址冲突
        conflicts = self.check_address_conflict()
        if conflicts:
            msg = "检测到地址冲突:\n"
            for c in conflicts:
                msg += f"  {c[0]} 与 {c[1]} 在 0x{c[2]:04X}~0x{c[3]:04X} 重叠\n"
            raise ValueError(msg)

        # 创建根元素
        root = ET.Element("file")

        # 添加芯片信息
        self._add_chip_metadata(root)

        # 创建 device
        device = ET.SubElement(root, "device", {"class": "Device"})

        dev_caption = ET.SubElement(device, "caption")
        dev_caption.text = self.chip_info.name

        dev_name = ET.SubElement(device, "name")
        dev_name.text = self.chip_info.name

        ET.SubElement(device, "view", {"class": "DeviceView"})

        # 构建每个实例
        for inst in self.instances:
            if not inst.enable:
                continue

            if inst.module_name not in self.modules:
                raise ValueError(
                    f"实例 {inst.name} 引用了未定义的模块 {inst.module_name}"
                )

            parser = self.modules[inst.module_name]
            self._build_instance(device, inst, parser)

        self._built_tree = root
        return root

    def _add_chip_metadata(self, root: ET.Element):
        """添加芯片元数据"""
        author = ET.SubElement(root, "author")
        author.text = self.chip_info.author

        version = ET.SubElement(root, "version")
        version.text = self.chip_info.version

        autoversion = ET.SubElement(root, "autoversion")
        autoversion.text = "1"

        revision = ET.SubElement(root, "revision")
        ET.SubElement(revision, "user").text = self.chip_info.author
        ET.SubElement(revision, "timestamp").text = "Auto Generated"
        ET.SubElement(revision, "autoversion").text = "1"
        ET.SubElement(revision, "description").text = (
            self.chip_info.description or "Generated by ChipXMLBuilder"
        )

    def _build_instance(
        self, parent: ET.Element, inst: InstanceConfig, parser: "ModuleParser"
    ):
        """构建单个实例的interface节点"""
        interface = ET.SubElement(parent, "interface", {"class": "Interface"})

        name_elem = ET.SubElement(interface, "name")
        name_elem.text = inst.name

        caption_elem = ET.SubElement(interface, "caption")
        caption_elem.text = inst.caption

        ET.SubElement(interface, "view", {"class": "InterfaceView"})

        addr_elem = ET.SubElement(interface, "address")
        addr_elem.text = self.chip_info.i2c_address

        ET.SubElement(interface, "wordsize").text = str(self.chip_info.wordsize)
        ET.SubElement(interface, "raddr_wordsize").text = str(
            self.chip_info.raddr_wordsize
        )

        # 获取模块的所有字段
        fields = parser.get_fields()

        # 应用覆盖规则
        fields = self._apply_overrides(inst, fields)

        # 添加字段
        for field in fields:
            self._build_field(interface, field, inst.base_addr)

    def _apply_overrides(self, inst: InstanceConfig, fields: List[Dict]) -> List[Dict]:
        """应用覆盖规则"""
        result = []
        for field in fields:
            field_copy = field.copy()
            field_name = field_copy.get("fieldname", "")

            for rule in self.overrides:
                if re.match(rule.instance_pattern, inst.name):
                    if re.match(rule.field_pattern, field_name):
                        if rule.property_name in field_copy:
                            field_copy[rule.property_name] = rule.new_value

            result.append(field_copy)
        return result

    def _build_field(self, parent: ET.Element, field: Dict, base_addr: int):
        """构建单个field节点"""

        field_elem = ET.SubElement(parent, "field", {"class": "Field"})

        rel_addr = int(field.get("address", "0"))
        startat = int(field.get("startat", "0"))
        size = int(field.get("size", "1"))
        abs_addr = base_addr + rel_addr

        # name
        fieldname = field.get("fieldname", "")
        name = self._remove_prefixes(fieldname)
        rtlname = field.get("rtlname", "")
        if "[" in rtlname and "]" in rtlname:
            match = re.search(r"\[(\d+:\d+)\]$", rtlname)
            if match and "[" not in name:
                name = name + "[" + match.group(1) + "]"

        ET.SubElement(field_elem, "name").text = name

        # datatype
        datatype = field.get("datatype", "Fixed").lower()
        ET.SubElement(field_elem, "datatype").text = datatype

        # description
        if "description" in field and field["description"]:
            ET.SubElement(field_elem, "description").text = field["description"]

        # caption - 使用 tablename 或 fieldname，移除 [n:m] 后缀
        caption = field.get("tablename", field.get("fieldname", ""))
        # 移除 [n:m] 后缀
        caption = re.sub(r"\[\d+:\d+\]$", "", caption)
        caption_text = (
            "i2c_" + self._remove_i2c_prefix(caption)
            if not caption.startswith("i2c_")
            else caption
        )
        ET.SubElement(field_elem, "caption").text = caption_text

        # defaultvalue
        defaultvalue = field.get("defaultvalue", "0")
        if defaultvalue.isdigit():
            defaultvalue = f"0x{int(defaultvalue):X}"
        elif all(c in "0123456789ABCDEFabcdef" for c in defaultvalue):
            try:
                val = int(defaultvalue, 16)
                num_bytes = (size + 7) // 8
                defaultvalue = f"0x{val:0{num_bytes * 2}X}"
            except ValueError:
                pass
        ET.SubElement(field_elem, "defaultvalue").text = defaultvalue

        # address, mask, shift
        # 检测 byteorder 来判断 startat 是 MSB 还是 LSB
        # Little Endian 标记表示 startat 是 LSB（最低位）
        byteorder = field.get("byteorder", "").lower()
        is_lsb_convention = "little" in byteorder

        masks, shifts, _ = calculate_masks_and_shifts(
            abs_addr, startat, size, fieldname, is_lsb_convention
        )

        ET.SubElement(field_elem, "address").text = f"0x{abs_addr:04X}.{startat}"

        mask_parts = [
            f"0x{addr:04X}:0x{masks[addr]:02X}" for addr in sorted(masks.keys())
        ]
        ET.SubElement(field_elem, "mask").text = "{" + ",".join(mask_parts) + "}"

        shift_parts = [f"0x{addr:04X}:{shifts[addr]}" for addr in sorted(shifts.keys())]
        ET.SubElement(field_elem, "shift").text = "{" + ",".join(shift_parts) + "}"

        # size, use
        ET.SubElement(field_elem, "size").text = str(size)
        ET.SubElement(field_elem, "use").text = field.get("use", "User")

        # view
        view_class = "ChoiceView" if datatype == "choice" else "TextView"
        ET.SubElement(field_elem, "view", {"class": view_class})

        # indexval (for choice)
        if datatype == "choice" and "valuedescriptions" in field:
            for vd in field["valuedescriptions"]:
                if "value" in vd and "description" in vd:
                    try:
                        val_str = vd["value"]
                        if val_str.startswith("0x"):
                            idx = int(val_str, 16)
                        elif val_str.startswith("0b"):
                            idx = int(val_str, 2)
                        elif val_str and all(c in "01" for c in val_str):
                            # 二进制字符串（如 '0010'）按二进制解析
                            idx = int(val_str, 2)
                        else:
                            idx = int(val_str)
                        idxval = ET.SubElement(
                            field_elem, "indexval", {"index": str(idx)}
                        )
                        idxval.text = vd["description"]
                    except ValueError:
                        pass

        # readonly
        if field.get("access") == "r":
            ET.SubElement(field_elem, "readonly").text = "True"

    def _remove_prefixes(self, name: str) -> str:
        """移除 i2c_ 前缀，保留 rb_ 前缀"""
        name = self._remove_i2c_prefix(name)
        # 注意：rb_ 前缀表示只读字段，不应移除
        return name

    def _remove_i2c_prefix(self, name: str) -> str:
        """移除 i2c_ 前缀"""
        if name.startswith("i2c_"):
            return name[4:]
        return name

    def export_xml(self, output_path: str, pretty: bool = True):
        """
        导出XML文件

        Args:
            output_path: 输出文件路径
            pretty: 是否格式化输出
        """
        if self._built_tree is None:
            raise RuntimeError("请先调用 build() 方法")

        xml_str = ET.tostring(self._built_tree, encoding="unicode")

        if pretty:
            dom = minidom.parseString(xml_str)
            pretty_xml = dom.toprettyxml(indent="    ")
            lines = [line for line in pretty_xml.split("\n") if line.strip()]
            xml_str = "\n".join(lines)

        os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
        with open(output_path, "w", encoding="utf-8") as f:
            f.write(xml_str)

    def export_json(self, output_path: str):
        """导出JSON格式（用于其他工具集成）"""
        if self._built_tree is None:
            raise RuntimeError("请先调用 build() 方法")

        # 简单转换
        def elem_to_dict(elem):
            result = {}
            for child in elem:
                if len(child) == 0:
                    result[child.tag] = child.text or ""
                else:
                    if child.tag not in result:
                        result[child.tag] = []
                    result[child.tag].append(elem_to_dict(child))
            return result

        data = elem_to_dict(self._built_tree)

        os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
        with open(output_path, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)

    def export_excel(self, output_path: str):
        """导出地址映射表（用于人工审查）"""
        if not OPENPYXL_AVAILABLE:
            raise ImportError("请先安装openpyxl: pip install openpyxl")

        wb = Workbook()
        ws = wb.active
        ws.title = "Address Map"

        # 表头
        headers = [
            "Instance",
            "Module",
            "Field Name",
            "Address",
            "Size",
            "Access",
            "Description",
        ]
        ws.append(headers)

        for inst in self.instances:
            if not inst.enable:
                continue
            if inst.module_name not in self.modules:
                continue

            parser = self.modules[inst.module_name]
            for field in parser.get_fields():
                rel_addr = int(field.get("address", "0"))
                abs_addr = inst.base_addr + rel_addr

                row = [
                    inst.name,
                    inst.module_name,
                    field.get("fieldname", ""),
                    f"0x{abs_addr:04X}",
                    field.get("size", ""),
                    field.get("access", ""),
                    field.get("description", "")[:50],  # 截断
                ]
                ws.append(row)

        # 调整列宽
        for col in ws.columns:
            max_length = 0
            column = col[0].column_letter
            for cell in col:
                try:
                    if len(str(cell.value)) > max_length:
                        max_length = len(str(cell.value))
                except:
                    pass
            adjusted_width = min(max_length + 2, 50)
            ws.column_dimensions[column].width = adjusted_width

        os.makedirs(os.path.dirname(output_path) or ".", exist_ok=True)
        wb.save(output_path)

    def get_info(self) -> Dict:
        """获取构建器状态信息"""
        return {
            "chip_info": self.chip_info,
            "modules": list(self.modules.keys()),
            "instances": [inst.name for inst in self.instances],
            "total_instances": len(self.instances),
            "enabled_instances": sum(1 for i in self.instances if i.enable),
            "overrides": len(self.overrides),
        }


class ModuleParser:
    """
    子模块XML解析器
    解析类似CDR.xml格式的模块定义文件
    """

    def __init__(self, xml_path: str):
        self.xml_path = xml_path
        self.tree = ET.parse(xml_path)
        self.root = self.tree.getroot()
        self._fields: Optional[List[Dict]] = None

    def get_fields(self) -> List[Dict]:
        """获取所有字段定义"""
        if self._fields is not None:
            return self._fields

        fields = []
        for field_elem in self.root.findall("field"):
            field = {}

            for child in field_elem:
                if child.tag == "valuedescription":
                    if "valuedescriptions" not in field:
                        field["valuedescriptions"] = []
                    vd = {}
                    for vd_child in child:
                        vd[vd_child.tag] = vd_child.text or ""
                    field["valuedescriptions"].append(vd)
                else:
                    field[child.tag] = child.text or ""

            fields.append(field)

        self._fields = fields
        return fields

    def get_address_range(self) -> Tuple[int, int]:
        """获取地址范围 (min, max)"""
        fields = self.get_fields()
        if not fields:
            return (0, 0)

        addrs = [int(f.get("address", "0")) for f in fields]
        return (min(addrs), max(addrs))


def calculate_masks_and_shifts(
    start_addr: int,
    start_bit: int,
    size: int,
    field_name: str = "unknown",
    is_lsb_convention: bool = False,
) -> Tuple[Dict, Dict, int]:
    """
    计算跨字节字段的 mask 和 shift

    根据原始 XML 的格式，每个字节都有独立的 mask 和 shift 值。
    对于大端格式（MSB在前），字段从高位地址向低位地址分布。

    Args:
        start_addr: 起始地址
        start_bit: 起始位（根据原始 XML，7 表示 MSB，0 表示 LSB）
        size: 字段大小（位数）
        field_name: 字段名称（用于调试）
        is_lsb_convention: 是否为 LSB 约定

    Returns:
        (masks_dict, shifts_dict, end_addr)

    示例1: 40位字段，start_addr=0x610, start_bit=7, size=40
        - 分布在 5 个字节: 0x610, 0x611, 0x612, 0x613, 0x614
        - masks: {0x610: 0xFF, 0x611: 0xFF, 0x612: 0xFF, 0x613: 0xFF, 0x614: 0xFF}
        - shifts: {0x610: -32, 0x611: -24, 0x612: -16, 0x613: -8, 0x614: 0}

    示例2: 9位字段，start_addr=0x623, start_bit=0, size=9
        - 分布在 2 个字节: 0x623, 0x624
        - masks: {0x623: 0x01, 0x624: 0xFF}
        - shifts: {0x623: -8, 0x624: 0}
    """
    masks = {}
    shifts = {}

    # 启发式检测：如果 start_bit=0 且 size>1，可能是 LSB 约定
    # 但 AG.xml 中 9位字段 (size=9, startat=0) 实际上使用的是 MSB 约定
    # 让我们根据原始 XML 的模式来判断

    if start_bit == 7:
        # MSB 在起始地址的 bit 7，字段向低位延伸
        # 例如 40位字段：bit 39:32 在 0x610, ..., bit 7:0 在 0x614
        remaining_bits = size
        current_addr = start_addr
        current_msb = 7  # 每个字节从 bit 7 开始

        # 首先计算需要多少个字节
        num_bytes = (size + 7) // 8
        if size % 8 == 0:
            num_bytes = size // 8

        # 计算每个字节的 shift（从最高地址到最低地址）
        # 最高地址的字节包含最低有效位，shift = 0
        # 每向上一字节，shift 减 8
        for i in range(num_bytes):
            addr = start_addr + i
            # 计算这个字节包含多少位
            if i == 0:
                # 第一个字节可能不是完整的 8 位（如果从 bit 7 开始，通常是 8 位）
                bits_in_byte = min(8, remaining_bits)
            else:
                bits_in_byte = min(8, remaining_bits)

            # mask: 对于完整字节是 0xFF，对于部分字节需要计算
            if bits_in_byte == 8:
                mask = 0xFF
            else:
                # 从 bit 7 向下取 bits_in_byte 位
                mask = ((1 << bits_in_byte) - 1) << (8 - bits_in_byte)

            masks[addr] = mask
            # shift: 最高地址的字节 shift=0，每向上一字节减 8
            shifts[addr] = -(num_bytes - 1 - i) * 8

            remaining_bits -= bits_in_byte

        end_addr = start_addr + num_bytes - 1

    elif start_bit == 0:
        # LSB 在起始地址的 bit 0，字段向高位延伸
        # 例如 9位字段：bit 0 在 0x623, bits 8:1 在 0x624
        # mask: {0x0623:0x01, 0x0624:0xFF}
        remaining_bits = size
        byte_idx = 0

        while remaining_bits > 0:
            addr = start_addr + byte_idx

            if byte_idx == 0:
                # 第一个字节从 bit 0 开始，向上取位
                # 对于 9位字段，第一个字节取 1 位 (bit 0)
                bits_in_byte = min(8, remaining_bits)
                # 但是当 start_bit=0 时，第一个字节只取到使剩余位数为 8 的倍数的位数
                # 例如 9位：第一个字节取 1 位，第二个字节取 8 位
                # 例如 10位：第一个字节取 2 位，第二个字节取 8 位
                bits_in_first = remaining_bits % 8
                if bits_in_first == 0:
                    bits_in_first = 8
                bits_in_byte = bits_in_first
                # mask: 从 bit 0 向上取 bits_in_byte 位
                mask = (1 << bits_in_byte) - 1
            else:
                # 后续字节从 bit 0 开始，取最多 8 位
                bits_in_byte = min(8, remaining_bits)
                mask = 0xFF if bits_in_byte == 8 else (1 << bits_in_byte) - 1

            masks[addr] = mask
            remaining_bits -= bits_in_byte
            byte_idx += 1

        # 计算 shift
        num_bytes = byte_idx
        for i in range(num_bytes):
            addr = start_addr + i
            # 最高地址的字节 shift=0，每向上一字节减 8
            shifts[addr] = -(num_bytes - 1 - i) * 8

        end_addr = start_addr + byte_idx - 1

    else:
        # 其他 start_bit 值（如 3, 4, 5, 6）
        # 需要更复杂的逻辑
        remaining_bits = size
        current_addr = start_addr
        first_byte = True
        byte_idx = 0

        while remaining_bits > 0:
            addr = start_addr + byte_idx

            if first_byte:
                # 第一个字节从 start_bit 开始，向下取位
                bits_in_byte = min(start_bit + 1, remaining_bits)
                # mask: 从 start_bit 向下取 bits_in_byte 位
                mask = ((1 << bits_in_byte) - 1) << (start_bit - bits_in_byte + 1)
                first_byte = False
            else:
                # 后续字节从 bit 7 开始，取最多 8 位
                bits_in_byte = min(8, remaining_bits)
                mask = (
                    0xFF
                    if bits_in_byte == 8
                    else ((1 << bits_in_byte) - 1) << (8 - bits_in_byte)
                )

            masks[addr] = mask
            remaining_bits -= bits_in_byte
            byte_idx += 1

        # 计算 shift
        num_bytes = byte_idx
        for i in range(num_bytes):
            addr = start_addr + i
            shifts[addr] = -(num_bytes - 1 - i) * 8

        end_addr = start_addr + byte_idx - 1

    return masks, shifts, end_addr


# 为了保持向后兼容，保留原有的build_chip_xml函数
def build_chip_xml(cdr_xml_path: str, output_path: str):
    """
    从单个CDR.xml构建芯片级XML（兼容旧接口）

    Args:
        cdr_xml_path: CDR.xml文件路径
        output_path: 输出文件路径
    """
    builder = ChipXMLBuilder()
    builder.set_chip_info(name="GSU1K1r4", version="1.0.0")
    builder.add_module("CDR", cdr_xml_path)

    # 添加5个CDR实例
    builder.add_instance("CdrUp", "CDR", base_addr=0x1000, instance_id=0)
    builder.add_instance("CdrDp1", "CDR", base_addr=0x1100, instance_id=1)
    builder.add_instance("CdrDp2", "CDR", base_addr=0x1200, instance_id=2)
    builder.add_instance("CdrDp3", "CDR", base_addr=0x1300, instance_id=3)
    builder.add_instance("CdrDp4", "CDR", base_addr=0x1400, instance_id=4)

    builder.build()
    builder.export_xml(output_path)


if __name__ == "__main__":
    import sys

    if len(sys.argv) >= 2:
        config_path = sys.argv[1]
        output_dir = sys.argv[2] if len(sys.argv) > 2 else "./output"

        builder = ChipXMLBuilder()
        builder.load_config(config_path)

        print(f"芯片信息: {builder.chip_info}")
        print(f"模块: {list(builder.modules.keys())}")
        print(f"实例: {[i.name for i in builder.instances]}")

        # 检查冲突
        conflicts = builder.check_address_conflict()
        if conflicts:
            print("警告: 检测到地址冲突!")
            for c in conflicts:
                print(f"  {c[0]} 与 {c[1]} 重叠")

        # 构建并导出
        builder.build()

        xml_path = os.path.join(output_dir, f"{builder.chip_info.name}_Chip.xml")
        builder.export_xml(xml_path)
        print(f"已导出: {xml_path}")

        # 同时导出Excel地址表
        excel_path = os.path.join(
            output_dir, f"{builder.chip_info.name}_AddressMap.xlsx"
        )
        builder.export_excel(excel_path)
        print(f"已导出: {excel_path}")
    else:
        print("用法: python chip_builder.py <config.xlsx> [output_dir]")
